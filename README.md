# Metamodel - Go Code Generator for Struct Field Constants

## Overview

Hard-coded strings are common in development, especially when working with databases. For example:
```sql
SELECT * FROM "gorm_tests" WHERE "id" = xxx AND "name" = 'yyy'
```

**Metamodel** is a code generation tool that scans Go structs with `json` or `bson` tags and automatically generates type-safe field name constants. This eliminates string literals in your code and provides compile-time safety when referencing struct field names. Reference: [JPA MetaModel](https://www.baeldung.com/hibernate-criteria-queries-metamodel)

The code can more clean
```go
db.Table(metamodel_.GormTest_.TableName).
	Select(
		metamodel_.GormTest_.Id.String(),
		metamodel_.GormTest_.IsActive.String(),
		metamodel_.GormTest_.FeatureName.String(),
		metamodel_.GormTest_.PriceUnit.String(),
		metamodel_.GormTest_.Type.String(),
	).
	Where(metamodel_.GormTest_.IsActive.IsTrueString()).
	Where(metamodel_.GormTest_.FeatureName.EqualString("test")).
	Order(metamodel_.GormTest_.Id.AscString()).
	Find(&results)
// instead of
db.Table(metamodel_.GormTest_.TableName).
	Select(
		"id",
		"is_active",
		"feature_name",
		"price_unit",
		"type",
	).
	Where("is_active == true").
	Where("feature_name = 'test'").
	Order("id ASC").
	Find(&results)
// output 

// SELECT id,is_active,feature_name,price_unit,type FROM gorm_tests WHERE  is_active = true  AND  feature_name = test  ORDER BY  id ASC 
```

## Installation

Install the tool using `go install`:

```bash
go install github.com/namnv2496/metamodel@latest
```

Or build from source:

```bash
git clone https://github.com/namnv2496/metamodel.git
cd metamodel
go install .
```

## Uninstall

```bash
rm $(go env GOPATH)/bin/metamodel

go clean -cache -modcache

source ~/.zshrc

Close the terminal
```
## Usage

### Using with go generate (Recommended)

Add a `//go:generate` directive to your Go file:

```go
package repository

//go:generate metamodel -source=$GOFILE -destination=../generated/
type Scenarios struct {
	FeatureName string `json:"feature_name,omitempty"`
	ScenarioID  int    `json:"scenario_id"`
	Status      string `bson:"status"`
	Description string `json:"description,omitempty" bson:"desc"`
	IgnoreMe    string // no tag, should be ignored
	SkippedTag  string `json:"-"` // skip tag
}
```

Then run:

```bash
go generate ./...
```

## Output

```go
// Code generated by metamodel. DO NOT EDIT.
//go:generate metamodel -source=feature.go -destination=../generated/ -tag=json

package repository_

// Feature_ contains field name constants for Feature
var Feature_ = struct {
	TableName   string
	TableNames  string
	FeatureName string
	ScenarioID  string
	Status      string
	Description string
}{
	TableName:   "feature",
	TableNames:  "features",
	FeatureName: "feature_name",
	ScenarioID:  "scenario_id",
	Description: "description",
}

//go:generate metamodel -source=feature.go -destination=../generated/ -tag=bson
var Scenarios_ = struct {
	TableName   string
	TableNames  string
	Status      string
	Description string
}{
	TableName:   "scenarios",
	TableNames:  "scenarioss", // table name with 's'
	Status:      "status",
	Description: "desc",
}

//go:generate metamodel -source=$GOFILE -destination=../generated/ -tag=gorm
var GormTest_ = struct {
	TableName   string
	TableNames  string
	FeatureName Field
	Type        Field
	IsActive    Field
	GormElement Field
}{
	TableName:   "gorm_test",
	TableNames:  "gorm_tests", // table name with 's'
	FeatureName: "feature_name",
	Type:        "type",
	IsActive:    "is_active",
	GormElement: "gorm_element",
}
```

### Direct Command Line Usage

```bash
metamodel -source=path/to/your/file.go -destination=path/to/generate_file.go -tag=bson
```

# Example

```go
package main

import (
	"fmt"

	repository_ "github.com/namnv2496/exmaple/generated"
)

func main() {
	// Use the generated metamodel constants
	fmt.Println("Scenarios.TableName: ", metamodel_.Scenarios_.TableName)
	fmt.Println("Scenarios.Status: ", metamodel_.Scenarios_.Status)
	fmt.Println("Feature.ScenarioID: ", metamodel_.Feature_.ScenarioID)
	fmt.Println("AnotherModel.UserName: ", metamodel_.AnotherModel_.UserName)

	// build gorm query
	fmt.Println(metamodel_.GormTest_.FeatureName.Equal("1"))
	fmt.Println(metamodel_.GormTest_.FeatureName.Equal(2))
	fmt.Println(metamodel_.GormTest_.FeatureName.EqualString("5"))
	fmt.Println(metamodel_.GormTest_.FeatureName.EqualString(10))
	fmt.Println(metamodel_.GormTest_.FeatureName.WithDefaultOwner().Equal(1000))
	fmt.Println(metamodel_.GormTest_.FeatureName.WithOwner("features").Equal(1000))
	fmt.Println(metamodel_.GormTest_.FeatureName.WithOwnerString("features"))

	fmt.Println(metamodel_.Join("table", metamodel_.GormTest_.FeatureName.EqualString("1")))
	fmt.Println("select " + metamodel_.Columns(
		metamodel_.Scenarios_.Status.String(),
		metamodel_.Scenarios_.Description.String(),
	))
	fmt.Println("==========")
}

// Output
Scenarios.TableName:  scenarios
Scenarios.Status:  status
Feature.ScenarioID:  scenario_id
AnotherModel.UserName:  user_name
{feature_name 1}
{feature_name 2}
 feature_name = 5 
 feature_name = 10 
{ gorm_tests.feature_name  1000}
{ features.feature_name  1000}
 features.feature_name 
 JOIN table ON  feature_name = 1  
select status, desc
==========
```
