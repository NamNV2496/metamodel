package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// Config holds the configuration for code generation
type Config struct {
	Source      string
	Destination string
	PackageName string
	Tag         string
}

// StructMeta holds metadata for a struct
type StructMeta struct {
	Name   string
	Fields []FieldMeta
}

// FieldMeta holds metadata for a struct field
type FieldMeta struct {
	Name    string
	TagName string
}

const metamodelTemplate = `// Code generated by metamodel. DO NOT EDIT.
//go:generate metamodel -source={{.SourceFile}} -destination={{.Destination}} -tag={{.Tag}} 

package {{.PackageName}}
{{range .Structs}}
// {{.Name}}_ contains field name constants for {{.Name}}
var {{.Name}}_ = struct {
{{- range .Fields}}
	{{.Name}} string
{{- end}}
}{
{{- range .Fields}}
	{{.Name}}: "{{.TagName}}",
{{- end}}
}
{{end}}
`

// Generate generates metamodel code for the given configuration
func Generate(cfg Config) error {
	// Parse the source file
	structs, pkgName, err := ParseFile(cfg.Source, cfg.Tag)
	if err != nil {
		return fmt.Errorf("failed to parse source file: %w", err)
	}
	if len(structs) == 0 {
		return fmt.Errorf("no structs found in %s", cfg.Source)
	}
	if cfg.PackageName != "" {
		pkgName = cfg.PackageName + "_"
	}
	originalDest := cfg.Destination
	// Generate destination path
	destPath := cfg.Destination
	if destPath == "" {
		// No destination specified, create next to source file
		ext := filepath.Ext(cfg.Source)
		destPath = strings.TrimSuffix(cfg.Source, ext) + "_metamodel.go"
	} else if strings.HasSuffix(destPath, "/") || strings.HasSuffix(destPath, string(filepath.Separator)) {
		// Destination is a directory, create the directory and generate filename
		if err := os.MkdirAll(destPath, 0755); err != nil {
			return fmt.Errorf("failed to create destination directory: %w", err)
		}
		// Generate filename from source
		sourceBase := filepath.Base(cfg.Source)
		ext := filepath.Ext(sourceBase)
		filename := strings.TrimSuffix(sourceBase, ext) + "_metamodel.go"
		destPath = filepath.Join(destPath, filename)
	} else {
		// Destination is a file path, create directory if needed
		destDir := filepath.Dir(destPath)
		if destDir != "." && destDir != "" {
			if err := os.MkdirAll(destDir, 0755); err != nil {
				return fmt.Errorf("failed to create destination directory: %w", err)
			}
		}
	}

	// Prepare template data
	data := struct {
		SourceFile  string
		PackageName string
		Destination string
		Tag         string
		Structs     []StructMeta
	}{
		SourceFile:  filepath.Base(cfg.Source),
		PackageName: pkgName,
		Destination: originalDest,
		Tag:         cfg.Tag,
		Structs:     structs,
	}
	// Execute template
	tmpl, err := template.New("metamodel").Parse(metamodelTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}
	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		formatted = buf.Bytes()
	}
	// Write to destination file
	if err := os.WriteFile(destPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}
