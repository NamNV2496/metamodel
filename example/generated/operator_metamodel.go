// Code generated by metamodel. DO NOT EDIT.

package metamodel_

import (
	"fmt"
	"gorm.io/gorm/clause"
	"strings"
)

// Field represents a database column with its name and table name.
type Field struct {
	FieldName string
	TableName string
}

// Columns joins the given column expressions with a comma separator.
// Use it to build SELECT lists:
//
//	db.Select(Columns(
//	    GormTest_.FeatureName.String(),
//	    CategoryEntity_.Value.As("category_id"),
//	)).Where(...).GroupBy(...).Having(...).Order(...)
//
// Example full query:
//
//	db.Select(Columns(
//	    GormTest_.FeatureName.String(),
//	    "COUNT(*) as total",
//	)).Where(GormTest_.Status.Equal("active")).
//	  GroupBy(GormTest_.FeatureName.String()).
//	  Having(clause.Gt{Column: "COUNT(*)", Value: 5}).
//	  Order(GormTest_.CreatedAt.Desc()).
//	  Find(&results)
func Columns(cols ...string) string {
	return strings.Join(cols, ", ")
}

func Join(joinTable string, conditions ...string) string {
	return fmt.Sprintf(" JOIN %s ON %s ", joinTable, strings.Join(conditions, " AND "))
}

// Equal generates a GORM equality condition: "column = ?"
func (f Field) Equal(val any) clause.Eq {
	return clause.Eq{Column: f.FieldName, Value: val}
}

func (f Field) EqualString(val any) string {
	return fmt.Sprintf(" %s = %v ", f.FieldName, val)
}

// NotEqual generates a GORM not-equal condition: "column <> ?"
func (f Field) NotEqual(val any) clause.Neq {
	return clause.Neq{Column: f.FieldName, Value: val}
}

func (f Field) NotEqualString(val any) string {
	return fmt.Sprintf(" %s <> %v ", f.FieldName, val)
}

// In generates a GORM IN condition: "column IN (?)"
func (f Field) In(vals ...any) clause.IN {
	return clause.IN{Column: clause.Column{Name: f.FieldName}, Values: vals}
}

func (f Field) InString(vals ...any) string {
	var valStrs []string
	for _, v := range vals {
		valStrs = append(valStrs, fmt.Sprintf("%s", v))
	}
	return fmt.Sprintf(" %s IN (%s) ", f.FieldName, strings.Join(valStrs, ", "))
}

// Gt generates a GORM greater-than condition: "column > ?"
func (f Field) Gt(val any) clause.Gt {
	return clause.Gt{Column: f.FieldName, Value: val}
}

func (f Field) GtString(val any) string {
	return fmt.Sprintf(" %s > %v ", f.FieldName, val)
}

// Gte generates a GORM greater-than-or-equal condition: "column >= ?"
func (f Field) Gte(val any) clause.Gte {
	return clause.Gte{Column: f.FieldName, Value: val}
}

func (f Field) GteString(val any) string {
	return fmt.Sprintf(" %s >= %v ", f.FieldName, val)
}

// Lt generates a GORM less-than condition: "column < ?"
func (f Field) Lt(val any) clause.Lt {
	return clause.Lt{Column: f.FieldName, Value: val}
}

func (f Field) LtString(val any) string {
	return fmt.Sprintf(" %s < %v ", f.FieldName, val)
}

// Lte generates a GORM less-than-or-equal condition: "column <= ?"
func (f Field) Lte(val any) clause.Lte {
	return clause.Lte{Column: f.FieldName, Value: val}
}

func (f Field) LteString(val any) string {
	return fmt.Sprintf(" %s <= %v ", f.FieldName, val)
}

// IsTrue generates a GORM equality condition for boolean true.
func (f Field) IsTrue() clause.Eq {
	return clause.Eq{Column: f.FieldName, Value: true}
}

func (f Field) IsTrueString() string {
	return fmt.Sprintf(" %s = true ", f.FieldName)
}

// IsFalse generates a GORM equality condition for boolean false.
func (f Field) IsFalse() clause.Eq {
	return clause.Eq{Column: f.FieldName, Value: false}
}

func (f Field) IsFalseString() string {
	return fmt.Sprintf(" %s = false ", f.FieldName)
}

// Asc returns an ORDER BY ascending expression.
func (f Field) Asc() clause.OrderByColumn {
	return clause.OrderByColumn{Column: clause.Column{Name: f.FieldName}}
}

func (f Field) AscString() string {
	return fmt.Sprintf(" %s ASC ", f.FieldName)
}

// Desc returns an ORDER BY descending expression.
func (f Field) Desc() clause.OrderByColumn {
	return clause.OrderByColumn{Column: clause.Column{Name: f.FieldName}, Desc: true}
}

func (f Field) DescString() string {
	return fmt.Sprintf(" %s DESC ", f.FieldName)
}

// String returns the raw column name.
func (f Field) String() string {
	return f.FieldName
}

func (f Field) As(val any) string {
	return fmt.Sprintf(" %s as %v ", f.FieldName, val)
}

func (f Field) AddOwner(val any) Field {
	f.FieldName = fmt.Sprintf(" %v.%s ", val, f.FieldName)
	return f
}

func (f Field) WithOwnerString() string {
	return fmt.Sprintf(" %s.%s ", f.TableName, f.FieldName)
}

func (f Field) WithOwner() Field {
	f.FieldName = fmt.Sprintf(" %s.%s ", f.TableName, f.FieldName)
	return f
}

// QueryBuilder helps construct complete SQL SELECT statements.
type QueryBuilder struct {
	selectCols  []string
	fromTable   string
	whereConds  []string
	groupByCols []string
	havingConds []string
	orderByCols []string
}

// NewQueryBuilder creates a new QueryBuilder for the given table.
func NewQueryBuilder(tableName string) *QueryBuilder {
	return &QueryBuilder{
		fromTable: tableName,
	}
}

// Select adds columns to the SELECT clause.
func (qb *QueryBuilder) Select(cols ...string) *QueryBuilder {
	qb.selectCols = append(qb.selectCols, cols...)
	return qb
}

// Where adds conditions to the WHERE clause.
func (qb *QueryBuilder) Where(conditions ...string) *QueryBuilder {
	qb.whereConds = append(qb.whereConds, conditions...)
	return qb
}

// GroupBy adds columns to the GROUP BY clause.
func (qb *QueryBuilder) GroupBy(cols ...string) *QueryBuilder {
	qb.groupByCols = append(qb.groupByCols, cols...)
	return qb
}

// Having adds conditions to the HAVING clause.
func (qb *QueryBuilder) Having(conditions ...string) *QueryBuilder {
	qb.havingConds = append(qb.havingConds, conditions...)
	return qb
}

// OrderBy adds columns to the ORDER BY clause.
func (qb *QueryBuilder) OrderBy(cols ...string) *QueryBuilder {
	qb.orderByCols = append(qb.orderByCols, cols...)
	return qb
}

// Build constructs and returns the complete SQL SELECT statement as a string.
// Expected format: "SELECT a,b,c FROM table WHERE ... GROUP BY ... HAVING ... ORDER BY ..."
func (qb *QueryBuilder) Build() string {
	var query strings.Builder

	// SELECT clause
	query.WriteString("SELECT ")
	if len(qb.selectCols) > 0 {
		query.WriteString(strings.Join(qb.selectCols, ","))
	} else {
		query.WriteString("*")
	}

	// FROM clause
	query.WriteString(" FROM ")
	query.WriteString(qb.fromTable)

	// WHERE clause
	if len(qb.whereConds) > 0 {
		query.WriteString(" WHERE ")
		query.WriteString(strings.Join(qb.whereConds, " AND "))
	}

	// GROUP BY clause
	if len(qb.groupByCols) > 0 {
		query.WriteString(" GROUP BY ")
		query.WriteString(strings.Join(qb.groupByCols, ","))
	}

	// HAVING clause
	if len(qb.havingConds) > 0 {
		query.WriteString(" HAVING ")
		query.WriteString(strings.Join(qb.havingConds, " AND "))
	}

	// ORDER BY clause
	if len(qb.orderByCols) > 0 {
		query.WriteString(" ORDER BY ")
		query.WriteString(strings.Join(qb.orderByCols, ","))
	}

	return query.String()
}
